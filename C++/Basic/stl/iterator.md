# 迭代器

## 迭代器失效的几种场景
详情参考：https://www.cnblogs.com/linuxAndMcu/p/14621819.html
1. 当容器调用erase()方法后
2. 当容器调用insert()方法后
3. 如果容器扩容，在其他地方重新又开辟了一块内存。原来容器底层的内存上所保存的迭代器全都失效了

### 迭代器失效的解决办法
1. 对于序列式容器（如 vector，deque）的迭代器，**因为 vetor、deque 使用了连续分配的内存，erase操作删除一个元素导致后面所有的元素都会向前移动一个位置，这些元素的地址发生了变化，所以当前位置到容器末尾元素的所有迭代器全部失效**。
2. 对于链表式容器(如 list)，删除当前的 iterator，**仅仅会使当前的 iterator 失效，这是因为 list 之类的容器，使用了链表来实现，插入、删除一个结点不会对其他结点造成影响**。只要在 erase 时，递增当前 iterator 即可，并且 erase 方法可以返回下一个有效的 iterator。
3. 对于关联容器(如 map，set，multimap，multiset)，**删除当前的 iterator，仅仅会使当前的 iterator 失效**，只要在 erase 时，递增当前 iterator 即可。这是因为 map 之类的容器，使用了红黑树来实现，插入、删除一个结点不会对其他结点造成影响。**erase 迭代器只是被删元素的迭代器失效，但是返回值为 void，所以要采用erase(iter++)的方式删除迭代器**。
