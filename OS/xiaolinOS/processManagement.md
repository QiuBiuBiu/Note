# 进程管理

## 进程
### 进程的状态
1. 在一个进程的活动期间至少具备三种基本状态，即**运行状态、就绪状态、阻塞状态**。
2. 当然，进程还有另外两个基本状态：创建状态、结束状态
3. 挂起状态：描述进程没有占用实际的物理内存空间的情况。(如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，显然不是我们所希望的，毕竟物理内存空间是有限的，被阻塞状态的进程占用着物理内存就一种浪费物理内存的行为。)

### 进程控制结构
在操作系统中，是用**进程控制块**（process control block，PCB）数据结构来描述进程的。**PCB 是进程存在的唯一标识**，包含以下内容：
1. 进程描述信息：进程标识符和用户标识符
2. 进程控制和管理信息：当前状态和进程优先级
3. 资源分配清单：有关内存地址空间或虚拟地址空间的信息
4. CPU 相关信息：CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息都会被保存在相应的 PCB 中，以便进程重新执行时，能从断点处继续执行。

### 进程的上下文切换
各个进程之间是共享 CPU 资源的，在不同的时候进程之间需要切换，让不同的进程可以在 CPU 执行，那么这个一个进程切换到另一个进程运行，称为进程的上下文切换。

#### 进程的上下文切换到底是切换什么呢？
进程是由内核管理和调度的，所以进程的切换只能发生在**内核态**。所以，**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的资源**。

## 线程
线程是进程当中的一条执行流程。同一个进程内**多个线程之间可以共享代码段、数据段、打开的文件等资源**，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相对独立的。
1. 优点：
    - 一个进程中可以同时存在多个线程；
    - 各个线程之间可以并发执行；
    - 各个线程之间可以共享地址空间和文件等资源；
2. 缺点：
    - 当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃

## 线程与进程的比较
线程与进程的比较如下：
1. 进程是**资源（包括内存、打开的文件等）分配的单位，线程是 CPU 调度的单位**；
2. 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈；
3. 线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系；
4. 线程能减少并发执行的时间和空间开销；

对于，线程相比进程能减少开销，体现在：
1. 线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；
2. 线程的终止时间比进程快，因为线程释放的资源相比进程少很多；
3. 同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；
4. 由于**同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核**了，这就使得线程之间的数据交互效率更高了；

### 线程的上下文切换
线程与进程最大的区别在于：**线程是调度的基本单位，而进程则是资源拥有的基本单位**。所以，**所谓操作系统的任务调度，实际上的调度对象是线程**，而进程只是给线程提供了虚拟内存、全局变量等资源。

### 线程上下文切换的是什么？
1. 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
2. **当两个线程是属于同一个进程，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据**；


## 进程间通信方式总结
### 进程管理
由于每个进程的用户空间都是独立的，不能相互访问，这时就需要借助内核空间来实现进程间通信，原因很简单，每个进程都是共享一个内核空间。

#### 管道
Linux 内核提供了不少进程间通信的方式，其中最简单的方式就是管道，管道分为「匿名管道」和「命名管道」。

1. 匿名管道顾名思义，它没有名字标识，匿名管道是特殊文件只存在于内存，没有存在于文件系统中，shell 命令中的「|」竖线就是匿名管道，通信的数据是无格式的流并且大小受限，通信的方式是单向的，数据只能在一个方向上流动，如果要双向通信，需要创建两个管道，再来**匿名管道是只能用于存在父子关系的进程间通信，匿名管道的生命周期随着进程创建而建立，随着进程终止而消失**。

2. 命名管道突破了匿名管道只能在亲缘关系进程间的通信限制，因为使用命名管道的前提，需要在文件系统创建一个类型为 p 的设备文件，**那么毫无关系的进程就可以通过这个设备文件进行通信**。另外，不管是匿名管道还是命名管道，进程写入的数据都是缓存在内核中，另一个进程读取数据时候自然也是从内核中获取，同时通信数据都遵循先进先出原则，不支持 lseek 之类的文件定位操作。

#### 消息队列
消息队列**克服了管道通信的数据是无格式的字节流的问题**，消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型，发送数据时，会被分成一个一个独立的消息体，当然接收数据时，也要与发送方发送的消息体的数据类型保持一致，这样才能保证读取的数据是正确的。消息队列通信的速度不是最及时的，毕竟每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。

#### 共享内存
共享内存可以**解决消息队列通信中用户态与内核态之间数据拷贝过程带来的开销**，它直接分配一个共享空间，每个进程都可以直接访问，就像访问进程自己的空间一样快捷方便，不需要陷入内核态或者系统调用，大大提高了通信的速度，**享有最快的进程间通信方式之名**。但是便捷高效的共享内存通信，带来新的问题，多进程竞争同个共享资源会造成数据的错乱。

#### 信号量
那么，就需要信号量来**保护共享资源，以确保任何时刻只能有一个进程访问共享资源**，这种方式就是互斥访问。信号量不仅可以实现访问的互斥性，还可以实现进程间的同步，信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作。
1. 可以发现，信号初始化为 1，就代表着是**互斥信号量**，它可以保证共享内存在任何时刻只有一个进程在访问，这就很好的保护了共享内存。
2. 那么这时候，就可以用信号量来实现多进程同步的方式，我们可以初始化信号量为 0。(**生产者消费者**)

#### 信号
与信号量名字很相似的叫信号，它俩名字虽然相似，但功能一点儿都不一样。**信号是异步通信机制**，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件，信号事件的来源主要有硬件来源（如键盘 Cltr+C ）和软件来源（如 kill 命令），一旦有信号发生，进程有三种方式响应信号 1. 执行默认操作、2. 捕捉信号、3. 忽略信号。有两个信号是应用进程无法捕捉和忽略的，即 SIGKILL 和 SIGSTOP，这是为了方便我们能在任何时候结束或停止某个进程。

#### socket
前面说到的通信机制，都是工作于同一台主机，**如果要与不同主机的进程间通信，那么就需要 Socket 通信了**。Socket 实际上不仅用于不同的主机进程间通信，还可以用于本地主机进程间通信，可根据创建 Socket 的类型不同，分为三种常见的通信方式，一个是基于 TCP 协议的通信方式，一个是基于 UDP 协议的通信方式，一个是本地进程间通信方式。

### 线程管理
同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，**信号量也同样可以在线程间实现互斥与同步**：

1. 互斥的方式，可保证任意时刻只有一个线程访问共享资源；
2. 同步的方式，可保证线程 A 应在线程 B 之前执行；